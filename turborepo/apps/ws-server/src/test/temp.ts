import { Fs } from "@d0paminedriven/fs";
type CollapseSpaces<S extends string> =
  S extends `${infer T}  ${infer U}` ? CollapseSpaces<`${T} ${U}`> : S;

type Hyphenate<S extends string> = S extends `${infer T} ${infer U}`
  ? `${T}-${Hyphenate<U>}`
  : S;

type HyphenateUnderScores<T extends string> =
  T extends `${infer X}_${infer Y}` ? `${X}-${HyphenateUnderScores<Y>}` : T;

type OmitQuestionMark<T extends string> =
  T extends `${infer U}?${infer Z}` ? `${U}${OmitQuestionMark<Z>}` : T;

type OmitSemiColon<T extends string> = T extends `${infer U};${infer V}`
  ? `${U}${OmitSemiColon<V>}`
  : T;

type OmitExclamationMark<T extends string> =
  T extends `${infer U}!${infer X}` ? `${U}${OmitExclamationMark<X>}` : T;

type OmitCommas<T extends string> = T extends `${infer U},${infer X}`
  ? `${U}${OmitCommas<X>}`
  : T;

type OmitApostrophe<T extends string> = T extends `${infer U}'${infer X}`
  ? `${U}${OmitApostrophe<X>}`
  : T;

type OmitPeriod<T extends string> = T extends `${infer U}.${infer X}`
  ? `${U}${OmitPeriod<X>}`
  : T;

type OmitColons<T extends string> = T extends `${infer U}:${infer X}`
  ? `${U}${OmitColons<X>}`
  : T;

type HandleFloats<T extends string> = T extends `${infer U}.${infer X}` ? U & X extends number ?`${U}-point-${X}` : T : T;

type Clean<T extends string> = OmitSemiColon<
  OmitApostrophe<
    OmitQuestionMark<OmitExclamationMark<OmitColons<OmitCommas<OmitPeriod<HandleFloats<T>>>>>>
  >
>;

type ToSlug<T extends string> = Lowercase<
  HyphenateUnderScores<Hyphenate<CollapseSpaces<Clean<T>>>>
>;



const floatSlugifier = <const T extends string>(input:T) =>input
  .replace( /\b(\d+)\.(\d+)\b/, (_whole, intPart:number, decPart: number) => `${intPart}-point-${decPart}`) as HandleFloats<T>



function slugify<const T extends string>(title: T) {
  return floatSlugifier(title)
    .toLowerCase()
    .trim()
    .replace(/_+/g, "-") // _ -> -
    .normalize("NFD") // decomposes diacritical-chars (eg, รถ) into letter + diacritic
    .replace(/[\u0300-\u036f]/g, "") // remove diacritical marks (รถ->o)
    .replace(/[^a-z0-9 -]/g, "") // remove invalid chars (only A-Z, a-z, 0-9, space, and dash).
    .replace(/( )+/g, "-")
    .replace(/-+/g, "-")
    .replace(/^-+/, "")
    .replace(/-+$/, "") as ToSlug<T>;
}


const aiChatResponse = {
  type: "ai_chat_response",
  conversationId: "p51npk1wevp0qh9d17qo9bcw",
  userId: "x1sa9esbc7nb1bbhnn5uy9ct",
  provider: "anthropic",
  model: "claude-3-7-sonnet-latest",
  title: "Best Practices for Encrypting API Keys in TypeScript 5.8+",
  chunk:
    "# Best Practices for Encryption Key Management in TypeScript\n\nBelow I'll outline a comprehensive approach to generating secure encryption keys, managing salts, and implementing encryption/decryption for sensitive user data like API keys in a Node.js application with PostgreSQL storage.\n\n## 1. Key Generation and Management\n\nFirst, let's create a utility for generating and managing encryption keys:\n\n```typescript\n// src/utils/keyManagement.ts\nimport crypto from 'node:crypto';\nimport fs from 'node:fs/promises';\nimport path from 'node:path';\n\n// Configuration\nconst KEY_DIRECTORY = process.env.KEY_DIRECTORY || path.join(process.cwd(), 'keys');\nconst MASTER_KEY_FILE = path.join(KEY_DIRECTORY, 'master.key');\nconst ENCRYPTION_KEY_FILE = path.join(KEY_DIRECTORY, 'encryption.key');\nconst KEY_ITERATION_COUNT = 100000; // PBKDF2 iterations\nconst KEY_LENGTH = 32; // 256 bits\nconst SALT_LENGTH = 32; // 256 bits\n\n/**\n * Generates a secure random buffer of specified length\n */\nfunction generateSecureRandomBytes(length: number): Buffer {\n  return crypto.randomBytes(length);\n}\n\n/**\n * Derives an encryption key using PBKDF2\n */\nasync function deriveKey(\n  password: string | Buffer, \n  salt: Buffer, \n  iterations = KEY_ITERATION_COUNT,\n  keylen = KEY_LENGTH\n): Promise<Buffer> {\n  return new Promise((resolve, reject) => {\n    crypto.pbkdf2(password, salt, iterations, keylen, 'sha512', (err, derivedKey) => {\n      if (err) reject(err);\n      else resolve(derivedKey);\n    });\n  });\n}\n\n/**\n * Initializes encryption keys if they don't exist\n */\nasync function initializeKeys(): Promise<void> {\n  try {\n    // Create key directory if it doesn't exist\n    await fs.mkdir(KEY_DIRECTORY, { recursive: true });\n    \n    // Generate master key if it doesn't exist\n    try {\n      await fs.access(MASTER_KEY_FILE);\n    } catch (e) {\n      const masterKey = generateSecureRandomBytes(KEY_LENGTH);\n      await fs.writeFile(MASTER_KEY_FILE, masterKey, { mode: 0o600 }); // Restricted permissions\n      console.log('Generated new master key');\n    }\n    \n    // Generate encryption key if it doesn't exist\n    try {\n      await fs.access(ENCRYPTION_KEY_FILE);\n    } catch (e) {\n      const salt = generateSecureRandomBytes(SALT_LENGTH);\n      const masterKey = await fs.readFile(MASTER_KEY_FILE);\n      const encryptionKey = await deriveKey(masterKey, salt);\n      \n      // Store the encryption key along with its salt\n      const dataToStore = Buffer.concat([salt, encryptionKey]);\n      await fs.writeFile(ENCRYPTION_KEY_FILE, dataToStore, { mode: 0o600 });\n      console.log('Generated new encryption key');\n    }\n  } catch (err) {\n    console.error('Failed to initialize encryption keys:', err);\n    throw err;\n  }\n}\n\n/**\n * Retrieves the active encryption key\n */\nasync function getEncryptionKey(): Promise<{ key: Buffer; salt: Buffer }> {\n  try {\n    const data = await fs.readFile(ENCRYPTION_KEY_FILE);\n    const salt = data.subarray(0, SALT_LENGTH);\n    const key = data.subarray(SALT_LENGTH);\n    return { key, salt };\n  } catch (err) {\n    console.error('Failed to read encryption key:', err);\n    throw err;\n  }\n}\n\n/**\n * Key rotation function - generates a new encryption key\n */\nasync function rotateEncryptionKey(): Promise<void> {\n  try {\n    const salt = generateSecureRandomBytes(SALT_LENGTH);\n    const masterKey = await fs.readFile(MASTER_KEY_FILE);\n    const newEncryptionKey = await deriveKey(masterKey, salt);\n    \n    // Store with salt\n    const dataToStore = Buffer.concat([salt, newEncryptionKey]);\n    \n    // Create backup of old key\n    const timestamp = Date.now();\n    await fs.copyFile(\n      ENCRYPTION_KEY_FILE, \n      `${ENCRYPTION_KEY_FILE}.${timestamp}.bak`\n    );\n    \n    // Write new key\n    await fs.writeFile(ENCRYPTION_KEY_FILE, dataToStore, { mode: 0o600 });\n    console.log('Encryption key rotated successfully');\n  } catch (err) {\n    console.error('Failed to rotate encryption key:', err);\n    throw err;\n  }\n}\n```\n\n## 2. Encryption and Decryption Service\n\nNow, let's create a service for encrypting and decrypting user data:\n\n```typescript\n// src/utils/encryption.ts\nimport crypto from 'node:crypto';\nimport { getEncryptionKey, generateSecureRandomBytes } from './keyManagement';\n\nconst ALGORITHM = 'aes-256-gcm';\nconst IV_LENGTH = 16; // 128 bits\nconst AUTH_TAG_LENGTH = 16; // 128 bits\n\ntype EncryptedData = {\n  iv: Buffer;\n  authTag: Buffer;\n  encryptedData: Buffer;\n};\n\n/**\n * Encrypts sensitive data using AES-256-GCM\n */\nasync function encrypt(data: string): Promise<string> {\n  try {\n    const { key } = await getEncryptionKey();\n    const iv = generateSecureRandomBytes(IV_LENGTH);\n    \n    const cipher = crypto.createCipheriv(ALGORITHM, key, iv);\n    const encrypted = Buffer.concat([\n      cipher.update(data, 'utf8'),\n      cipher.final()\n    ]);\n    \n    const authTag = cipher.getAuthTag();\n    \n    // Format: IV + AuthTag + EncryptedData\n    const result: EncryptedData = {\n      iv,\n      authTag,\n      encryptedData: encrypted\n    };\n    \n    // Convert to Base64 for storage\n    return Buffer.concat([\n      result.iv,\n      result.authTag,\n      result.encryptedData\n    ]).toString('base64');\n  } catch (err) {\n    console.error('Encryption failed:', err);\n    throw new Error('Failed to encrypt data');\n  }\n}\n\n/**\n * Decrypts data that was encrypted with the encrypt function\n */\nasync function decrypt(encryptedBase64: string): Promise<string> {\n  try {\n    const { key } = await getEncryptionKey();\n    const encryptedBuffer = Buffer.from(encryptedBase64, 'base64');\n    \n    // Extract components\n    const iv = encryptedBuffer.subarray(0, IV_LENGTH);\n    const authTag = encryptedBuffer.subarray(IV_LENGTH, IV_LENGTH + AUTH_TAG_LENGTH);\n    const encryptedData = encryptedBuffer.subarray(IV_LENGTH + AUTH_TAG_LENGTH);\n    \n    // Decrypt\n    const decipher = crypto.createDecipheriv(ALGORITHM, key, iv);\n    decipher.setAuthTag(authTag);\n    \n    return Buffer.concat([\n      decipher.update(encryptedData),\n      decipher.final()\n    ]).toString('utf8');\n  } catch (err) {\n    console.error('Decryption failed:', err);\n    throw new Error('Failed to decrypt data');\n  }\n}\n```\n\n## 3. Database Repository for API Keys\n\nNext, let's create a repository for storing and retrieving encrypted API keys:\n\n```typescript\n// src/repositories/apiKeyRepository.ts\nimport { Pool } from 'pg';\nimport { encrypt, decrypt } from '../utils/encryption';\n\n// Initialize database connection\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : undefined\n});\n\ninterface ApiKey {\n  id: number;\n  userId: number;\n  name: string;\n  encryptedKey: string;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\ninterface ApiKeyInput {\n  userId: number;\n  name: string;\n  apiKey: string;\n}\n\nclass ApiKeyRepository {\n  /**\n   * Creates a new API key entry with encrypted key\n   */\n  async createApiKey(input: ApiKeyInput): Promise<ApiKey> {\n    const encryptedKey = await encrypt(input.apiKey);\n    \n    const result = await pool.query<ApiKey>(\n      `INSERT INTO api_keys (user_id, name, encrypted_key) \n       VALUES ($1, $2, $3) \n       RETURNING id, user_id as \"userId\", name, encrypted_key as \"encryptedKey\", \n                 created_at as \"createdAt\", updated_at as \"updatedAt\"`,\n      [input.userId, input.name, encryptedKey]\n    );\n    \n    return result.rows[0];\n  }\n  \n  /**\n   * Retrieves and decrypts an API key by ID\n   */\n  async getApiKey(id: number, userId: number): Promise<{ id: number; name: string; apiKey: string } | null> {\n    const result = await pool.query<ApiKey>(\n      `SELECT id, name, encrypted_key as \"encryptedKey\" \n       FROM api_keys \n       WHERE id = $1 AND user_id = $2`,\n      [id, userId]\n    );\n    \n    if (result.rows.length === 0) {\n      return null;\n    }\n    \n    const row = result.rows[0];\n    const apiKey = await decrypt(row.encryptedKey);\n    \n    return {\n      id: row.id,\n      name: row.name,\n      apiKey\n    };\n  }\n  \n  /**\n   * Lists API keys for a user (without the decrypted keys)\n   */\n  async listApiKeys(userId: number): Promise<Omit<ApiKey, 'encryptedKey'>[]> {\n    const result = await pool.query<ApiKey>(\n      `SELECT id, user_id as \"userId\", name, created_at as \"createdAt\", updated_at as \"updatedAt\"\n       FROM api_keys\n       WHERE user_id = $1\n       ORDER BY created_at DESC`,\n      [userId]\n    );\n    \n    return result.rows.map(({ encryptedKey, ...rest }) => rest);\n  }\n  \n  /**\n   * Updates an existing API key\n   */\n  async updateApiKey(id: number, userId: number, name: string, newApiKey?: string): Promise<ApiKey | null> {\n    // Start a transaction\n    const client = await pool.connect();\n    \n    try {\n      await client.query('BEGIN');\n      \n      // First check if the API key exists and belongs to the user\n      const checkResult = await client.query<ApiKey>(\n        'SELECT * FROM api_keys WHERE id = $1 AND user_id = $2',\n        [id, userId]\n      );\n      \n      if (checkResult.rows.length === 0) {\n        await client.query('ROLLBACK');\n        return null;\n      }\n      \n      let query: string;\n      let params: any[];\n      \n      if (newApiKey) {\n        // If updating the API key itself, encrypt the new value\n        const encryptedKey = await encrypt(newApiKey);\n        query = `\n          UPDATE api_keys \n          SET name = $1, encrypted_key = $2, updated_at = NOW() \n          WHERE id = $3 AND user_id = $4\n          RETURNING id, user_id as \"userId\", name, encrypted_key as \"encryptedKey\", \n                    created_at as \"createdAt\", updated_at as \"updatedAt\"\n        `;\n        params = [name, encryptedKey, id, userId];\n      } else {\n        // If only updating the name\n        query = `\n          UPDATE api_keys \n          SET name = $1, updated_at = NOW() \n          WHERE id = $2 AND user_id = $3\n          RETURNING id, user_id as \"userId\", name, encrypted_key as \"encryptedKey\", \n                    created_at as \"createdAt\", updated_at as \"updatedAt\"\n        `;\n        params = [name, id, userId];\n      }\n      \n      const result = await client.query<ApiKey>(query, params);\n      await client.query('COMMIT');\n      return result.rows[0];\n    } catch (error) {\n      await client.query('ROLLBACK');\n      throw error;\n    } finally {\n      client.release();\n    }\n  }\n  \n  /**\n   * Deletes an API key\n   */\n  async deleteApiKey(id: number, userId: number): Promise<boolean> {\n    const result = await pool.query(\n      'DELETE FROM api_keys WHERE id = $1 AND user_id = $2 RETURNING id',\n      [id, userId]\n    );\n    \n    return result.rowCount > 0;\n  }\n}\n```\n\n## 4. Database Migration for API Keys Table\n\nLet's create a SQL migration to set up the necessary table:\n\n```typescript\n// src/migrations/001_create_api_keys_table.ts\nimport { Pool } from 'pg';\n\nasync function up(pool: Pool): Promise<void> {\n  await pool.query(`\n    CREATE TABLE IF NOT EXISTS api_keys (\n      id SERIAL PRIMARY KEY,\n      user_id INTEGER NOT NULL,\n      name VARCHAR(255) NOT NULL,\n      encrypted_key TEXT NOT NULL,\n      created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n      updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n    );\n    \n    CREATE INDEX idx_api_keys_user_id ON api_keys(user_id);\n    \n    -- Add a trigger to automatically update the updated_at timestamp\n    CREATE OR REPLACE FUNCTION update_timestamp()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      NEW.updated_at = NOW();\n      RETURN NEW;\n    END;\n    $$ LANGUAGE plpgsql;\n    \n    CREATE TRIGGER set_timestamp\n    BEFORE UPDATE ON api_keys\n    FOR EACH ROW\n    EXECUTE FUNCTION update_timestamp();\n  `);\n}\n\nasync function down(pool: Pool): Promise<void> {\n  await pool.query(`\n    DROP TRIGGER IF EXISTS set_timestamp ON api_keys;\n    DROP FUNCTION IF EXISTS update_timestamp();\n    DROP TABLE IF EXISTS api_keys;\n  `);\n}\n```\n\n## 5. API Controller for API Keys\n\nFinally, let's create a controller for the API endpoints:\n\n```typescript\n// src/controllers/apiKeyController.ts\nimport { Request, Response } from 'express';\nimport { ApiKeyRepository, ApiKeyInput } from '../repositories/apiKeyRepository';\n\nconst apiKeyRepo = new ApiKeyRepository();\n\nclass ApiKeyController {\n  /**\n   * Create a new API key\n   */\n  async createApiKey(req: Request, res: Response): Promise<void> {\n    try {\n      const userId = req.user?.id; // Assuming auth middleware sets user\n      if (!userId) {\n        res.status(401).json({ error: 'Unauthorized' });\n        return;\n      }\n      \n      const { name, apiKey } = req.body;\n      \n      if (!name || !apiKey) {\n        res.status(400).json({ error: 'Name and API key are required' });\n        return;\n      }\n      \n      const input: ApiKeyInput = {\n        userId,\n        name,\n        apiKey\n      };\n      \n      const result = await apiKeyRepo.createApiKey(input);\n      \n      // Don't return the encrypted key in the response\n      const { encryptedKey, ...safeResult } = result;\n      res.status(201).json(safeResult);\n    } catch (error) {\n      console.error('Error creating API key:', error);\n      res.status(500).json({ error: 'Internal server error' });\n    }\n  }\n  \n  /**\n   * Get API key by ID\n   */\n  async getApiKey(req: Request, res: Response): Promise<void> {\n    try {\n      const userId = req.user?.id;\n      if (!userId) {\n        res.status(401).json({ error: 'Unauthorized' });\n        return;\n      }\n      \n      const id = parseInt(req.params.id, 10);\n      if (isNaN(id)) {\n        res.status(400).json({ error: 'Invalid ID format' });\n        return;\n      }\n      \n      const apiKey = await apiKeyRepo.getApiKey(id, userId);\n      \n      if (!apiKey) {\n        res.status(404).json({ error: 'API key not found' });\n        return;\n      }\n      \n      res.json(apiKey);\n    } catch (error) {\n      console.error('Error retrieving API key:', error);\n      res.status(500).json({ error: 'Internal server error' });\n    }\n  }\n  \n  /**\n   * List API keys for a user\n   */\n  async listApiKeys(req: Request, res: Response): Promise<void> {\n    try {\n      const userId = req.user?.id;\n      if (!userId) {\n        res.status(401).json({ error: 'Unauthorized' });\n        return;\n      }\n      \n      const apiKeys = await apiKeyRepo.listApiKeys(userId);\n      res.json(apiKeys);\n    } catch (error) {\n      console.error('Error listing API keys:', error);\n      res.status(500).json({ error: 'Internal server error' });\n    }\n  }\n  \n  /**\n   * Update an API key\n   */\n  async updateApiKey(req: Request, res: Response): Promise<void> {\n    try {\n      const userId = req.user?.id;\n      if (!userId) {\n        res.status(401).json({ error: 'Unauthorized' });\n        return;\n      }\n      \n      const id = parseInt(req.params.id, 10);\n      if (isNaN(id)) {\n        res.status(400).json({ error: 'Invalid ID format' });\n        return;\n      }\n      \n      const { name, apiKey } = req.body;\n      \n      if (!name) {\n        res.status(400).json({ error: 'Name is required' });\n        return;\n      }\n      \n      const updatedApiKey = await apiKeyRepo.updateApiKey(id, userId, name, apiKey);\n      \n      if (!updatedApiKey) {\n        res.status(404).json({ error: 'API key not found' });\n        return;\n      }\n      \n      // Don't return the encrypted key in the response\n      const { encryptedKey, ...safeResult } = updatedApiKey;\n      res.json(safeResult);\n    } catch (error) {\n      console.error('Error updating API key:', error);\n      res.status(500).json({ error: 'Internal server error' });\n    }\n  }\n  \n  /**\n   * Delete an API key\n   */\n  async deleteApiKey(req: Request, res: Response): Promise<void> {\n    try {\n      const userId = req.user?.id;\n      if (!userId) {\n        res.status(401).json({ error: 'Unauthorized' });\n        return;\n      }\n      \n      const id = parseInt(req.params.id, 10);\n      if (isNaN(id)) {\n        res.status(400).json({ error: 'Invalid ID format' });\n        return;\n      }\n      \n      const deleted = await apiKeyRepo.deleteApiKey(id, userId);\n      \n      if (!deleted) {\n        res.status(404).json({ error: 'API key not found' });\n        return;\n      }\n      \n      res.status(204).end();\n    } catch (error) {\n      console.error('Error deleting API key:', error);\n      res.status(500).json({ error: 'Internal server error' });\n    }\n  }\n}\n```\n\n## 6. Application Startup\n\nEnsure encryption keys are initialized when your application starts:\n\n```typescript\n// src/index.ts\nimport express from 'express';\nimport { initializeKeys } from './utils/keyManagement';\nimport { ApiKeyController } from './controllers/apiKeyController';\n\n// Initialize Express app\nconst app = express();\napp.use(express.json());\n\n// Initialize API key controller\nconst apiKeyController = new ApiKeyController();\n\n// Define API routes\napp.post('/api/keys', (req, res) => apiKeyController.createApiKey(req, res));\napp.get('/api/keys', (req, res) => apiKeyController.listApiKeys(req, res));\napp.get('/api/keys/:id', (req, res) => apiKeyController.getApiKey(req, res));\napp.put('/api/keys/:id', (req, res) => apiKeyController.updateApiKey(req, res));\napp.delete('/api/keys/:id', (req, res) => apiKeyController.deleteApiKey(req, res));\n\n// Initialize encryption keys and start server\nasync function startServer() {\n  try {\n    await initializeKeys();\n    console.log('Encryption keys initialized successfully');\n    \n    const PORT = process.env.PORT || 3000;\n    app.listen(PORT, () => {\n      console.log(`Server running on port ${PORT}`);\n    });\n  } catch (error) {\n    console.error('Failed to start server:', error);\n    process.exit(1);\n  }\n}\n\nstartServer();\n```\n\n## Security Best Practices\n\n1. **Key Storage**: Store encryption keys outside the application code and database, ideally in a dedicated key management service (KMS).\n\n2. **Key Rotation**: Implement periodic key rotation as shown in the code example.\n\n3. **Secure Key Permissions**: Use file permissions (0o600) to restrict access to key files.\n\n4. **Defense in Depth**: The solution uses both a master key and derived encryption keys.\n\n5. **Modern Algorithms**: AES-256-GCM provides authenticated encryption.\n\n6. **Secure Key Derivation**: PBKDF2 with high iteration count for key derivation.\n\n7. **Proper Error Handling**: Error messages don't reveal encryption details.\n\n8. **Separation of Concerns**: Clean separation between key management, encryption/decryption, and data storage.\n\nFor production environments, consider using a dedicated Key Management Service (KMS) like AWS KMS, Google Cloud KMS, or HashiCorp Vault instead of file-based key storage.",
  done: true
};
const fs = new Fs(process.cwd());

const path = `src/__out__/${aiChatResponse.provider}/${aiChatResponse.model}/${slugify(aiChatResponse.title)}.md`

fs.withWs(
  path,
  aiChatResponse.chunk
);
